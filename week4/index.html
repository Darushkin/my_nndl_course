<!DOCTYPE html>
<html>
<head>
    <title>Stock Prediction Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.8.6/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .controls { margin: 20px 0; }
        .progress { margin: 10px 0; }
        .charts { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .stock-chart { margin: 20px 0; }
        canvas { max-width: 100%; }
        button { margin: 5px; padding: 8px 16px; }
        input { margin: 5px; }
        .error { color: red; }
        .success { color: green; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multi-Stock GRU Prediction Demo</h1>
        
        <div class="controls">
            <input type="file" id="csvFile" accept=".csv">
            <button id="trainBtn" disabled>Train Model</button>
            <button id="predictBtn" disabled>Run Prediction</button>
        </div>

        <div class="progress">
            <div id="status">Upload CSV file to begin</div>
            <progress id="trainingProgress" value="0" max="100" style="width: 100%;"></progress>
        </div>

        <div class="charts">
            <div>
                <h3>Stock Accuracy Ranking</h3>
                <canvas id="accuracyChart"></canvas>
            </div>
            <div>
                <h3>Prediction Timeline</h3>
                <div id="timelineContainer"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import DataLoader from './data-loader.js';
        import GRUModel from './gru.js';

        class StockPredictionApp {
            constructor() {
                this.dataLoader = new DataLoader();
                this.model = null;
                this.currentPredictions = null;
                this.accuracyChart = null;
                this.isTraining = false;
                
                this.initializeEventListeners();
                console.log('App initialized with TensorFlow.js version', tf.version.tfjs);
            }

            initializeEventListeners() {
                const fileInput = document.getElementById('csvFile');
                const trainBtn = document.getElementById('trainBtn');
                const predictBtn = document.getElementById('predictBtn');

                fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
                trainBtn.addEventListener('click', () => this.trainModel());
                predictBtn.addEventListener('click', () => this.runPrediction());
            }

            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    document.getElementById('status').textContent = 'Loading CSV...';
                    document.getElementById('status').className = '';
                    await this.dataLoader.loadCSV(file);
                    
                    document.getElementById('status').textContent = 'Preprocessing data...';
                    const result = this.dataLoader.createSequences();
                    
                    document.getElementById('trainBtn').disabled = false;
                    document.getElementById('status').textContent = 
                        `Data loaded: ${result.symbols.length} stocks, ${result.X_train.shape[0]} training sequences. Click Train Model to begin training.`;
                    document.getElementById('status').className = 'success';
                    
                } catch (error) {
                    document.getElementById('status').textContent = `Error: ${error.message}`;
                    document.getElementById('status').className = 'error';
                    console.error('File upload error:', error);
                }
            }

            async trainModel() {
                if (this.isTraining) return;
                
                this.isTraining = true;
                const trainBtn = document.getElementById('trainBtn');
                const predictBtn = document.getElementById('predictBtn');
                
                trainBtn.disabled = true;
                predictBtn.disabled = true;

                try {
                    const { X_train, y_train, X_test, y_test, symbols } = this.dataLoader;
                    
                    if (!X_train || X_train.shape[0] === 0) {
                        throw new Error('No training data available. Please check your CSV file.');
                    }

                    console.log('Training data shape:', X_train.shape);
                    console.log('Training labels shape:', y_train.shape);

                    // Create model with correct input shape
                    const sequenceLength = X_train.shape[1];
                    const featuresPerTimestep = X_train.shape[2];
                    this.model = new GRUModel([sequenceLength, featuresPerTimestep], y_train.shape[1]);
                    
                    document.getElementById('status').textContent = 'Training model...';
                    document.getElementById('status').className = '';
                    
                    // Use fewer epochs for testing
                    await this.model.train(X_train, y_train, X_test, y_test, 10, 16);
                    
                    predictBtn.disabled = false;
                    document.getElementById('status').textContent = 'Training completed. Click Run Prediction to evaluate.';
                    document.getElementById('status').className = 'success';
                    
                } catch (error) {
                    document.getElementById('status').textContent = `Training failed: ${error.message}`;
                    document.getElementById('status').className = 'error';
                    console.error('Training error:', error);
                } finally {
                    this.isTraining = false;
                    trainBtn.disabled = false;
                }
            }

            async runPrediction() {
                if (!this.model) {
                    alert('Please train the model first');
                    return;
                }

                try {
                    document.getElementById('status').textContent = 'Running predictions...';
                    document.getElementById('status').className = '';
                    
                    const { X_test, y_test, symbols } = this.dataLoader;
                    
                    const predictions = await this.model.predict(X_test);
                    const evaluation = this.model.evaluatePerStock(y_test, predictions, symbols);
                    
                    this.currentPredictions = evaluation;
                    this.visualizeResults(evaluation, symbols);
                    
                    document.getElementById('status').textContent = 'Prediction completed. Results displayed below.';
                    document.getElementById('status').className = 'success';
                    
                    // Clean up
                    predictions.dispose();
                    
                } catch (error) {
                    document.getElementById('status').textContent = `Prediction error: ${error.message}`;
                    document.getElementById('status').className = 'error';
                    console.error('Prediction error:', error);
                }
            }

            visualizeResults(evaluation, symbols) {
                this.createAccuracyChart(evaluation.stockAccuracies, symbols);
                this.createTimelineCharts(evaluation.stockPredictions, symbols);
            }

            createAccuracyChart(accuracies, symbols) {
                const ctx = document.getElementById('accuracyChart');
                if (!ctx) {
                    console.error('Accuracy chart canvas not found');
                    return;
                }
                
                const chartContext = ctx.getContext('2d');
                
                // Sort stocks by accuracy
                const sortedEntries = Object.entries(accuracies)
                    .sort(([,a], [,b]) => b - a);
                
                const sortedSymbols = sortedEntries.map(([symbol]) => symbol);
                const sortedAccuracies = sortedEntries.map(([, accuracy]) => accuracy * 100);

                if (this.accuracyChart) {
                    this.accuracyChart.destroy();
                }

                this.accuracyChart = new Chart(chartContext, {
                    type: 'bar',
                    data: {
                        labels: sortedSymbols,
                        datasets: [{
                            label: 'Prediction Accuracy (%)',
                            data: sortedAccuracies,
                            backgroundColor: sortedAccuracies.map(acc => 
                                acc > 60 ? 'rgba(75, 192, 192, 0.8)' : 
                                acc > 50 ? 'rgba(255, 205, 86, 0.8)' : 
                                'rgba(255, 99, 132, 0.8)'
                            ),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        scales: {
                            x: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Accuracy (%)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `Accuracy: ${context.raw.toFixed(2)}%`
                                }
                            }
                        }
                    }
                });
            }

            createTimelineCharts(predictions, symbols) {
                const container = document.getElementById('timelineContainer');
                if (!container) {
                    console.error('Timeline container not found');
                    return;
                }
                
                container.innerHTML = '';

                // Show top 3 stocks by accuracy for timeline visualization
                const topStocks = Object.keys(predictions).slice(0, Math.min(3, Object.keys(predictions).length));

                topStocks.forEach(symbol => {
                    const stockPredictions = predictions[symbol];
                    const chartContainer = document.createElement('div');
                    chartContainer.className = 'stock-chart';
                    chartContainer.innerHTML = `<h4>${symbol} Prediction Timeline</h4><canvas id="timeline-${symbol}"></canvas>`;
                    container.appendChild(chartContainer);

                    const canvas = document.getElementById(`timeline-${symbol}`);
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // Sample predictions for cleaner visualization
                    const sampleSize = Math.min(20, stockPredictions.length);
                    const sampleData = stockPredictions.slice(0, sampleSize);
                    
                    const correctData = sampleData.map(p => p.correct ? 1 : 0);
                    const labels = sampleData.map((_, i) => i + 1);

                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Correct Predictions',
                                data: correctData,
                                borderColor: 'rgb(75, 192, 192)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                fill: false,
                                tension: 0.1,
                                pointBackgroundColor: sampleData.map(p => 
                                    p.correct ? 'rgb(75, 192, 192)' : 'rgb(255, 99, 132)'
                                ),
                                pointBorderColor: sampleData.map(p => 
                                    p.correct ? 'rgb(75, 192, 192)' : 'rgb(255, 99, 132)'
                                )
                            }]
                        },
                        options: {
                            scales: {
                                y: {
                                    min: 0,
                                    max: 1,
                                    ticks: {
                                        stepSize: 1,
                                        callback: (value) => value === 1 ? 'Correct' : value === 0 ? 'Wrong' : ''
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Prediction Number'
                                    }
                                }
                            }
                        }
                    });
                });
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new StockPredictionApp();
        });
    </script>
</body>
</html>
